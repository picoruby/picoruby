module WebSocket
  # @sidebar error
  class WebSocketError < StandardError
  end
  # @sidebar error
  class HandshakeError < WebSocketError
  end
  # @sidebar error
  class ProtocolError < WebSocketError
  end
  # @sidebar error
  class ConnectionClosed < WebSocketError
  end

  OPCODE_CONTINUATION: Integer
  OPCODE_TEXT: Integer
  OPCODE_BINARY: Integer
  OPCODE_CLOSE: Integer
  OPCODE_PING: Integer
  OPCODE_PONG: Integer

  CLOSE_NORMAL: Integer
  CLOSE_GOING_AWAY: Integer
  CLOSE_PROTOCOL_ERROR: Integer
  CLOSE_UNSUPPORTED_DATA: Integer
  CLOSE_ABNORMAL: Integer

  WEBSOCKET_GUID: String

  type fragment_t = {
    opcode: Integer,
    payload: String
  }

  class Client
    @url: String
    @host: String
    @port: Integer
    @path: String
    @socket: (TCPSocket | SSLSocket)?
    @headers: Hash[String, String]
    @fragments: Array[fragment_t]
    @use_ssl: bool
    @ssl_context: SSLContext?

    attr_reader url: String
    attr_reader host: String
    attr_reader port: Integer
    attr_reader path: String
    attr_accessor ssl_context: SSLContext?

    def initialize: (String) -> void

    def self.connect: (String) { (Client) -> void } -> void
                    | (String) -> Client

    def add_header: (String, String) -> void

    def connect: () -> bool

    def connected?: () -> bool

    def send_text: (String) -> void

    def send_binary: (String) -> void

    def send: (String, ?type: Symbol) -> void

    def receive: (?timeout: Numeric?) -> String?

    def ping: (?String) -> void

    def close: (?Integer, ?String) -> void

    private def parse_url: (String) -> void

    private def perform_handshake: () -> bool

    private def read_http_response: () -> String

    private def read_line: () -> String

    private def send_frame: (Integer, String) -> void

    private def receive_frame: () -> [Integer, String]

    private def mask_data: (String, String) -> String

    private def handle_close_frame: (String) -> void
  end
end
