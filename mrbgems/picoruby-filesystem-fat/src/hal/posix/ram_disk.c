#include <stdlib.h>
#include <string.h>

#include "ram_disk.h"

/* Disk Status Bits (DSTATUS) */
#define STA_NOINIT		0x01	/* Drive not initialized */
#define STA_NODISK		0x02	/* No medium in the drive */
#define STA_PROTECT		0x04	/* Write protected */


#define SECTOR_SIZE     512
#define SECTOR_COUNT    256

#define PRK_DESCRIPTION  "PRK Firmware"

/* PRK_DESCRIPTION should be located at the beginning of README. see msc_init() */
#define README_CONTENT \
PRK_DESCRIPTION "\n\nWelcome to PRK Firmware!\n\n\
Usage:\n\
- Drag and drop your `keymap.rb` into this directory\n\
- Then, your keyboard will be automatically rebooted. That's all!\n\n\
Notice:\n\
- Make sure you always have a backup of your `keymap.rb`\n\
  because upgrading prk_firmware-*.uf2 will remove it from flash\n\n\
https://github.com/picoruby/prk_firmware\n"

#define README_LENGTH (sizeof(README_CONTENT) - 1)

BYTE initial_disk[4][SECTOR_SIZE] =
{
  //------------- Block0: Boot Sector -------------//
  {
    0xEB, 0x3C, 0x90,       //    BS_jmpBoot
    'P' , 'i' , 'c' , 'o' , 'R' , 'u' , 'b' , 'y', //    BS_OEMName
    SECTOR_SIZE & 0xFF, SECTOR_SIZE >> 8 & 0xFF,   // ** BPB_BytePerSec **
    0x01,                   //    BPB_SecPerClus
    0x01, 0x00,             //    BPB_RsvdSecCnt
    0x01,                   //    BPB_NumFATs
    0x80, 0x00,             // ** BPB_RootEntCnt **
    SECTOR_COUNT & 0xFF, SECTOR_COUNT >> 8 & 0xFF, // ** BPB_TotSec16 **
    0xF8,                   //    BPB_Media
    0x01, 0x00,             //    BPB_FATSz16
    0x01, 0x00,             //    BPB_SecPerTrk
    0x01, 0x00,             //    BPB_NumHeads
    0x00, 0x00, 0x00, 0x00, //    BPB_HiddSec
    0x00, 0x00, 0x00, 0x00, //    BPB_TotSec32
    0x80,                   //    BS_DrvNum
    0x00,                   //    BS_ErrFlags
    0x29,                   //    BS_BootSig
    0x34, 0x12, 0x00, 0x00, //    BS_VolID
    'P', 'R', 'K', 'F', 'i', 'r', 'm', 'w', 'a', 'r', 'e', // BS_VolLab
    'F' , 'A' , 'T' , '1' , '2' , ' ' , ' ' , ' ' ,        // BS_FilSysType
    /* Zerofill until BS_BootSign (0xAA55 at offset 510) */
    0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
  },

  //------------- Block1: FAT12 Table -------------//
  {
    0xF8, 0xFF, 0xFF, 0xFF, 0x0F // // first 2 entries must be F8FF, third entry is cluster end of readme file
  },

  //------------- Block2: Root Directory -------------//
  {
    // first entry is volume label
    'P' , 'R' , 'K' , 'F' , 'i' , 'r' , 'm' , 'w' , 'a' , 'r' , 'e' , 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // second entry is readme file
    'R' , 'E' , 'A' , 'D' , 'M' , 'E' , ' ' , ' ' , 'T' , 'X' , 'T' , 0x20, 0x00, 0xC6, 0x52, 0x6D,
    0x65, 0x43, 0x65, 0x43, 0x00, 0x00, 0x88, 0x6D, 0x65, 0x43, 0x02, 0x00,
    // "README.TXT" files size (4 Bytes little endian)
    README_LENGTH & 0xFF,
    README_LENGTH >> 8 & 0xFF,
    README_LENGTH >> 16 & 0xFF,
    README_LENGTH >> 24
  },

  //------------- Block3: Readme Content -------------//
  README_CONTENT
};

static BYTE *ram_disk = NULL;

int
RAM_disk_initialize(void)
{
  if (ram_disk) return 0;
  ram_disk = malloc(SECTOR_SIZE * SECTOR_COUNT);
  if (ram_disk) {
    memset(ram_disk, 0, SECTOR_SIZE * SECTOR_COUNT);
    memcpy(ram_disk, &initial_disk, SECTOR_SIZE * 4);
    return 0;
  } else {
    return STA_NODISK;
  }
}

int
RAM_disk_status(void)
{
  if (ram_disk) {
    return 0;
  } else {
    return STA_NOINIT;
  }
}

int
RAM_disk_read(BYTE *buff, LBA_t sector, UINT count)
{
  memcpy(buff, ram_disk + sector * SECTOR_SIZE, count * SECTOR_SIZE);
  return 0;
}

int
RAM_disk_write(const BYTE *buff, LBA_t sector, UINT count)
{
  memcpy(ram_disk + sector * SECTOR_SIZE, buff, count * SECTOR_SIZE);
  return 0;
}

DWORD
get_fattime(void)
{
  DWORD time = 1<<21 | 1<<16;
  return time;
}

DRESULT
RAM_disk_ioctl(BYTE cmd, int *buff)
{
  switch (cmd) {
    case CTRL_SYNC:
      // TODO
      break;
    case GET_BLOCK_SIZE:
      // TODO
      return RES_ERROR;
    case CTRL_TRIM:
      // TODO
      return RES_ERROR;
    case GET_SECTOR_SIZE:
      *buff = SECTOR_SIZE;
      break;
    case GET_SECTOR_COUNT:
      *buff = SECTOR_COUNT;
      break;
    default :
      return RES_PARERR;
  }
  return RES_OK;
}
