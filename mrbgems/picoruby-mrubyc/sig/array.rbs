# <!-- rdoc-file=array.c -->
# An Array is an ordered, integer-indexed collection of objects, called
# *elements*. Any object (even another array) may be an array element, and an
# array can contain objects of different types.
#
# ## Array Indexes
#
# Array indexing starts at 0, as in C or Java.
#
# A positive index is an offset from the first element:
#
# *   Index 0 indicates the first element.
# *   Index 1 indicates the second element.
# *   ...
#
#
# A negative index is an offset, backwards, from the end of the array:
#
# *   Index -1 indicates the last element.
# *   Index -2 indicates the next-to-last element.
# *   ...
#
#
# A non-negative index is *in range* if and only if it is smaller than the size
# of the array.  For a 3-element array:
#
# *   Indexes 0 through 2 are in range.
# *   Index 3 is out of range.
#
#
# A negative index is *in range* if and only if its absolute value is not larger
# than the size of the array.  For a 3-element array:
#
# *   Indexes -1 through -3 are in range.
# *   Index -4 is out of range.
#
#
# Although the effective index into an array is always an integer, some methods
# (both within and outside of class Array) accept one or more non-integer
# arguments that are [integer-convertible
# objects](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
#
# ## Creating Arrays
#
# You can create an Array object explicitly with:
#
# *   An [array literal](rdoc-ref:literals.rdoc@Array+Literals):
#
#         [1, 'one', :one, [2, 'two', :two]]
#
# *   A [%w or %W: string-array
#     Literal](rdoc-ref:literals.rdoc@25w+and+-25W-3A+String-Array+Literals):
#
#         %w[foo bar baz] # => ["foo", "bar", "baz"]
#         %w[1 % *]       # => ["1", "%", "*"]
#
# *   A [%i pr %I: symbol-array
#     Literal](rdoc-ref:literals.rdoc@25i+and+-25I-3A+Symbol-Array+Literals):
#
#         %i[foo bar baz] # => [:foo, :bar, :baz]
#         %i[1 % *]       # => [:"1", :%, :*]
#
# *   Method Kernel#Array:
#
#         Array(["a", "b"])             # => ["a", "b"]
#         Array(1..5)                   # => [1, 2, 3, 4, 5]
#         Array(key: :value)            # => [[:key, :value]]
#         Array(nil)                    # => []
#         Array(1)                      # => [1]
#         Array({:a => "a", :b => "b"}) # => [[:a, "a"], [:b, "b"]]
#
# *   Method Array.new:
#
#         Array.new               # => []
#         Array.new(3)            # => [nil, nil, nil]
#         Array.new(4) {Hash.new} # => [{}, {}, {}, {}]
#         Array.new(3, true)      # => [true, true, true]
#
#     Note that the last example above populates the array with references to
#     the same object. This is recommended only in cases where that object is a
#     natively immutable object such as a symbol, a numeric, `nil`, `true`, or
#     `false`.
#
#     Another way to create an array with various objects, using a block; this
#     usage is safe for mutable objects such as hashes, strings or other arrays:
#
#         Array.new(4) {|i| i.to_s } # => ["0", "1", "2", "3"]
#
#     Here is a way to create a multi-dimensional array:
#
#         Array.new(3) {Array.new(3)}
#         # => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
#
#
# A number of Ruby methods, both in the core and in the standard library,
# provide instance method `to_a`, which converts an object to an array.
#
# *   ARGF#to_a
# *   Array#to_a
# *   Enumerable#to_a
# *   Hash#to_a
# *   MatchData#to_a
# *   NilClass#to_a
# *   OptionParser#to_a
# *   Range#to_a
# *   Set#to_a
# *   Struct#to_a
# *   Time#to_a
# *   Benchmark::Tms#to_a
# *   CSV::Table#to_a
# *   Enumerator::Lazy#to_a
# *   Gem::List#to_a
# *   Gem::NameTuple#to_a
# *   Gem::Platform#to_a
# *   Gem::RequestSet::Lockfile::Tokenizer#to_a
# *   Gem::SourceList#to_a
# *   OpenSSL::X509::Extension#to_a
# *   OpenSSL::X509::Name#to_a
# *   Racc::ISet#to_a
# *   Rinda::RingFinger#to_a
# *   Ripper::Lexer::Elem#to_a
# *   RubyVM::InstructionSequence#to_a
# *   YAML::DBM#to_a
#
#
# ## Example Usage
#
# In addition to the methods it mixes in through the Enumerable module, the
# Array class has proprietary methods for accessing, searching and otherwise
# manipulating arrays.
#
# Some of the more common ones are illustrated below.
#
# ## Accessing Elements
#
# Elements in an array can be retrieved using the Array#[] method.  It can take
# a single integer argument (a numeric index), a pair of arguments (start and
# length) or a range. Negative indices start counting from the end, with -1
# being the last element.
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr[2]    #=> 3
#     arr[100]  #=> nil
#     arr[-3]   #=> 4
#     arr[2, 3] #=> [3, 4, 5]
#     arr[1..4] #=> [2, 3, 4, 5]
#     arr[1..-3] #=> [2, 3, 4]
#
# Another way to access a particular array element is by using the #at method
#
#     arr.at(0) #=> 1
#
# The #slice method works in an identical manner to Array#[].
#
# To raise an error for indices outside of the array bounds or else to provide a
# default value when that happens, you can use #fetch.
#
#     arr = ['a', 'b', 'c', 'd', 'e', 'f']
#     arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
#     arr.fetch(100, "oops") #=> "oops"
#
# The special methods #first and #last will return the first and last elements
# of an array, respectively.
#
#     arr.first #=> 1
#     arr.last  #=> 6
#
# To return the first `n` elements of an array, use #take
#
#     arr.take(3) #=> [1, 2, 3]
#
# #drop does the opposite of #take, by returning the elements after `n` elements
# have been dropped:
#
#     arr.drop(3) #=> [4, 5, 6]
#
# ## Obtaining Information about an Array
#
# Arrays keep track of their own length at all times.  To query an array about
# the number of elements it contains, use #length, #count or #size.
#
#     browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
#     browsers.length #=> 5
#     browsers.count #=> 5
#
# To check whether an array contains any elements at all
#
#     browsers.empty? #=> false
#
# To check whether a particular item is included in the array
#
#     browsers.include?('Konqueror') #=> false
#
# ## Adding Items to Arrays
#
# Items can be added to the end of an array by using either #push or #<<
#
#     arr = [1, 2, 3, 4]
#     arr.push(5) #=> [1, 2, 3, 4, 5]
#     arr << 6    #=> [1, 2, 3, 4, 5, 6]
#
# #unshift will add a new item to the beginning of an array.
#
#     arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]
#
# With #insert you can add a new element to an array at any position.
#
#     arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]
#
# Using the #insert method, you can also insert multiple values at once:
#
#     arr.insert(3, 'orange', 'pear', 'grapefruit')
#     #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
#
# ## Removing Items from an Array
#
# The method #pop removes the last element in an array and returns it:
#
#     arr =  [1, 2, 3, 4, 5, 6]
#     arr.pop #=> 6
#     arr #=> [1, 2, 3, 4, 5]
#
# To retrieve and at the same time remove the first item, use #shift:
#
#     arr.shift #=> 1
#     arr #=> [2, 3, 4, 5]
#
# To delete an element at a particular index:
#
#     arr.delete_at(2) #=> 4
#     arr #=> [2, 3, 5]
#
# To delete a particular element anywhere in an array, use #delete:
#
#     arr = [1, 2, 2, 3]
#     arr.delete(2) #=> 2
#     arr #=> [1,3]
#
# A useful method if you need to remove `nil` values from an array is #compact:
#
#     arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, 'bar', 7, 'baz']
#
# Another common need is to remove duplicate elements from an array.
#
# It has the non-destructive #uniq, and destructive method #uniq!
#
#     arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
#     arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]
#
# ## Iterating over Arrays
#
# Like all classes that include the Enumerable module, Array has an each method,
# which defines what elements should be iterated over and how.  In case of
# Array's #each, all elements in the Array instance are yielded to the supplied
# block in sequence.
#
# Note that this operation leaves the array unchanged.
#
#     arr = [1, 2, 3, 4, 5]
#     arr.each {|a| print a -= 10, " "}
#     # prints: -9 -8 -7 -6 -5
#     #=> [1, 2, 3, 4, 5]
#
# Another sometimes useful iterator is #reverse_each which will iterate over the
# elements in the array in reverse order.
#
#     words = %w[first second third fourth fifth sixth]
#     str = ""
#     words.reverse_each {|word| str += "#{word} "}
#     p str #=> "sixth fifth fourth third second first "
#
# The #map method can be used to create a new array based on the original array,
# but with the values modified by the supplied block:
#
#     arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
#     arr                   #=> [1, 2, 3, 4, 5]
#     arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
#     arr                   #=> [1, 4, 9, 16, 25]
#
# ## Selecting Items from an Array
#
# Elements can be selected from an array according to criteria defined in a
# block.  The selection can happen in a destructive or a non-destructive manner.
#  While the destructive operations will modify the array they were called on,
# the non-destructive methods usually return a new array with the selected
# elements, but leave the original array unchanged.
#
# ### Non-destructive Selection
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.select {|a| a > 3}       #=> [4, 5, 6]
#     arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
#     arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
#     arr                          #=> [1, 2, 3, 4, 5, 6]
#
# ### Destructive Selection
#
# #select! and #reject! are the corresponding destructive methods to #select and
# #reject
#
# Similar to #select vs. #reject, #delete_if and #keep_if have the exact
# opposite result when supplied with the same block:
#
#     arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
#     arr                         #=> [4, 5, 6]
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
#     arr                       #=> [1, 2, 3]
#
# ## What's Here
#
# First, what's elsewhere. Class Array:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Array provides methods that are useful for:
#
# *   [Creating an Array](rdoc-ref:Array@Methods+for+Creating+an+Array)
# *   [Querying](rdoc-ref:Array@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Array@Methods+for+Comparing)
# *   [Fetching](rdoc-ref:Array@Methods+for+Fetching)
# *   [Assigning](rdoc-ref:Array@Methods+for+Assigning)
# *   [Deleting](rdoc-ref:Array@Methods+for+Deleting)
# *   [Combining](rdoc-ref:Array@Methods+for+Combining)
# *   [Iterating](rdoc-ref:Array@Methods+for+Iterating)
# *   [Converting](rdoc-ref:Array@Methods+for+Converting)
# *   [And more....](rdoc-ref:Array@Other+Methods)
#
#
# ### Methods for Creating an Array
#
# *   ::[]: Returns a new array populated with given objects.
# *   ::new: Returns a new array.
# *   ::try_convert: Returns a new array created from a given object.
#
#
# ### Methods for Querying
#
# *   #length, #size: Returns the count of elements.
# *   #include?: Returns whether any element `==` a given object.
# *   #empty?: Returns whether there are no elements.
# *   #all?: Returns whether all elements meet a given criterion.
# *   #any?: Returns whether any element meets a given criterion.
# *   #none?: Returns whether no element `==` a given object.
# *   #one?: Returns whether exactly one element `==` a given object.
# *   #count: Returns the count of elements that meet a given criterion.
# *   #find_index, #index: Returns the index of the first element that meets a
#     given criterion.
# *   #rindex: Returns the index of the last element that meets a given
#     criterion.
# *   #hash: Returns the integer hash code.
#
#
# ### Methods for Comparing
#
# *   #<=>: Returns -1, 0, or 1 * as `self` is less than, equal to, or greater
#     than a given object.
# *   #==: Returns whether each element in `self` is `==` to the corresponding
#     element in a given object.
# *   #eql?: Returns whether each element in `self` is `eql?` to the
#     corresponding element in a given object.
#
#
# ### Methods for Fetching
#
# These methods do not modify `self`.
#
# *   #[]: Returns one or more elements.
# *   #fetch: Returns the element at a given offset.
# *   #first: Returns one or more leading elements.
# *   #last: Returns one or more trailing elements.
# *   #max: Returns one or more maximum-valued elements, as determined by `<=>`
#     or a given block.
# *   #min: Returns one or more minimum-valued elements, as determined by `<=>`
#     or a given block.
# *   #minmax: Returns the minimum-valued and maximum-valued elements, as
#     determined by `<=>` or a given block.
# *   #assoc: Returns the first element that is an array whose first element
#     `==` a given object.
# *   #rassoc: Returns the first element that is an array whose second element
#     `==` a given object.
# *   #at: Returns the element at a given offset.
# *   #values_at: Returns the elements at given offsets.
# *   #dig: Returns the object in nested objects that is specified by a given
#     index and additional arguments.
# *   #drop: Returns trailing elements as determined by a given index.
# *   #take: Returns leading elements as determined by a given index.
# *   #drop_while: Returns trailing elements as determined by a given block.
# *   #take_while: Returns leading elements as determined by a given block.
# *   #slice: Returns consecutive elements as determined by a given argument.
# *   #sort: Returns all elements in an order determined by `<=>` or a given
#     block.
# *   #reverse: Returns all elements in reverse order.
# *   #compact: Returns an array containing all non-`nil` elements.
# *   #select, #filter: Returns an array containing elements selected by a given
#     block.
# *   #uniq: Returns an array containing non-duplicate elements.
# *   #rotate: Returns all elements with some rotated from one end to the other.
# *   #bsearch: Returns an element selected via a binary search as determined by
#     a given block.
# *   #bsearch_index: Returns the index of an element selected via a binary
#     search as determined by a given block.
# *   #sample: Returns one or more random elements.
# *   #shuffle: Returns elements in a random order.
#
#
# ### Methods for Assigning
#
# These methods add, replace, or reorder elements in `self`.
#
# *   #[]=: Assigns specified elements with a given object.
# *   #push, #append, #<<: Appends trailing elements.
# *   #unshift, #prepend: Prepends leading elements.
# *   #insert: Inserts given objects at a given offset; does not replace
#     elements.
# *   #concat: Appends all elements from given arrays.
# *   #fill: Replaces specified elements with specified objects.
# *   #replace: Replaces the content of `self` with the content of a given
#     array.
# *   #reverse!: Replaces `self` with its elements reversed.
# *   #rotate!: Replaces `self` with its elements rotated.
# *   #shuffle!: Replaces `self` with its elements in random order.
# *   #sort!: Replaces `self` with its elements sorted, as determined by `<=>`
#     or a given block.
# *   #sort_by!: Replaces `self` with its elements sorted, as determined by a
#     given block.
#
#
# ### Methods for Deleting
#
# Each of these methods removes elements from `self`:
#
# *   #pop: Removes and returns the last element.
# *   #shift:  Removes and returns the first element.
# *   #compact!: Removes all `nil` elements.
# *   #delete: Removes elements equal to a given object.
# *   #delete_at: Removes the element at a given offset.
# *   #delete_if: Removes elements specified by a given block.
# *   #keep_if: Removes elements not specified by a given block.
# *   #reject!: Removes elements specified by a given block.
# *   #select!, #filter!: Removes elements not specified by a given block.
# *   #slice!: Removes and returns a sequence of elements.
# *   #uniq!: Removes duplicates.
#
#
# ### Methods for Combining
#
# *   #&: Returns an array containing elements found both in `self` and a given
#     array.
# *   #intersection: Returns an array containing elements found both in `self`
#     and in each given array.
# *   #+: Returns an array containing all elements of `self` followed by all
#     elements of a given array.
# *   #-: Returns an array containing all elements of `self` that are not found
#     in a given array.
# *   #|: Returns an array containing all elements of `self` and all elements of
#     a given array, duplicates removed.
# *   #union: Returns an array containing all elements of `self` and all
#     elements of given arrays, duplicates removed.
# *   #difference: Returns an array containing all elements of `self` that are
#     not found in any of the given arrays..
# *   #product: Returns or yields all combinations of elements from `self` and
#     given arrays.
#
#
# ### Methods for Iterating
#
# *   #each: Passes each element to a given block.
# *   #reverse_each:  Passes each element, in reverse order, to a given block.
# *   #each_index: Passes each element index to a given block.
# *   #cycle: Calls a given block with each element, then does so again, for a
#     specified number of times, or forever.
# *   #combination: Calls a given block with combinations of elements of `self`;
#     a combination does not use the same element more than once.
# *   #permutation: Calls a given block with permutations of elements of `self`;
#     a permutation does not use the same element more than once.
# *   #repeated_combination: Calls a given block with combinations of elements
#     of `self`; a combination may use the same element more than once.
# *   #repeated_permutation: Calls a given block with permutations of elements
#     of `self`; a permutation may use the same element more than once.
#
#
# ### Methods for Converting
#
# *   #map, #collect: Returns an array containing the block return-value for
#     each element.
# *   #map!, #collect!: Replaces each element with a block return-value.
# *   #flatten: Returns an array that is a recursive flattening of `self`.
# *   #flatten!: Replaces each nested array in `self` with the elements from
#     that array.
# *   #inspect, #to_s: Returns a new String containing the elements.
# *   #join: Returns a newsString containing the elements joined by the field
#     separator.
# *   #to_a: Returns `self` or a new array containing all elements.
# *   #to_ary: Returns `self`.
# *   #to_h: Returns a new hash formed from the elements.
# *   #transpose: Transposes `self`, which must be an array of arrays.
# *   #zip: Returns a new array of arrays containing `self` and given arrays;
#     follow the link for details.
#
#
# ### Other Methods
#
# *   #*: Returns one of the following:
#
#     *   With integer argument `n`, a new array that is the concatenation of
#         `n` copies of `self`.
#     *   With string argument `field_separator`, a new string that is
#         equivalent to `join(field_separator)`.
#
#
# *   #abbrev: Returns a hash of unambiguous abbreviations for elements.
# *   #pack: Packs the elements into a binary sequence.
# *   #sum: Returns a sum of elements according to either `+` or a given block.
#

# @sidebar builtin
class Array[unchecked out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - Array.new -> new_empty_array
  #   - Array.new(array) -> new_array
  #   - Array.new(size) -> new_array
  #   - Array.new(size, default_value) -> new_array
  #   - Array.new(size) {|index| ... } -> new_array
  # -->
  # Returns a new Array.
  #
  # With no block and no arguments, returns a new empty Array object.
  #
  # With no block and a single Array argument `array`, returns a new Array formed
  # from `array`:
  #
  #     a = Array.new([:foo, 'bar', 2])
  #     a.class # => Array
  #     a # => [:foo, "bar", 2]
  #
  # With no block and a single Integer argument `size`, returns a new Array of the
  # given size whose elements are all `nil`:
  #
  #     a = Array.new(3)
  #     a # => [nil, nil, nil]
  #
  # With no block and arguments `size` and `default_value`, returns an Array of
  # the given size; each element is that same `default_value`:
  #
  #     a = Array.new(3, 'x')
  #     a # => ['x', 'x', 'x']
  #
  # With a block and argument `size`, returns an Array of the given size; the
  # block is called with each successive integer `index`; the element for that
  # `index` is the return value from the block:
  #
  #     a = Array.new(3) {|index| "Element #{index}" }
  #     a # => ["Element 0", "Element 1", "Element 2"]
  #
  # Raises ArgumentError if `size` is negative.
  #
  # With a block and no argument, or a single argument `0`, ignores the block and
  # returns a new empty Array.
  #
  def initialize: () -> instance
                | (::Array[Elem] ary) -> instance
                | (int size, ?Elem val) -> instance

  public

  # <!--
  #   rdoc-file=array.c
  #   - array & other_array -> new_array
  # -->
  # Returns a new Array containing each element found in both `array` and Array
  # `other_array`; duplicates are omitted; items are compared using `eql?`:
  #
  #     [0, 1, 2, 3] & [1, 2] # => [1, 2]
  #     [0, 1, 0, 1] & [0, 1] # => [0, 1]
  #
  # Preserves order from `array`:
  #
  #     [0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]
  #
  # Related: Array#intersection.
  #
  def &: (::Array[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array * n -> new_array
  #   - array * string_separator -> new_string
  # -->
  # When non-negative argument Integer `n` is given, returns a new Array built by
  # concatenating the `n` copies of `self`:
  #
  #     a = ['x', 'y']
  #     a * 3 # => ["x", "y", "x", "y", "x", "y"]
  #
  # When String argument `string_separator` is given, equivalent to
  # `array.join(string_separator)`:
  #
  #     [0, [0, 1], {foo: 0}] * ', ' # => "0, 0, 1, {:foo=>0}"
  #
  def *: (string str) -> ::String
       | (int int) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array + other_array -> new_array
  # -->
  # Returns a new Array containing all elements of `array` followed by all
  # elements of `other_array`:
  #
  #     a = [0, 1] + [2, 3]
  #     a # => [0, 1, 2, 3]
  #
  # Related: #concat.
  #
  def +: [U] (Array[U]) -> ::Array[Elem | U]

  # <!--
  #   rdoc-file=array.c
  #   - array - other_array -> new_array
  # -->
  # Returns a new Array containing only those elements from `array` that are not
  # found in Array `other_array`; items are compared using `eql?`; the order from
  # `array` is preserved:
  #
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1] - [1] # => [0, 2, 3]
  #     [0, 1, 2, 3] - [3, 0] # => [1, 2]
  #     [0, 1, 2] - [4] # => [0, 1, 2]
  #
  # Related: Array#difference.
  #
  def -: [U] (Array[U]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array << object -> self
  # -->
  # Appends `object` to `self`; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a << :baz # => [:foo, "bar", 2, :baz]
  #
  # Appends `object` as one element, even if it is another Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a1 = a << [3, 4]
  #     a1 # => [:foo, "bar", 2, [3, 4]]
  #
  def <<: (Elem) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array <=> other_array -> -1, 0, or 1
  # -->
  # Returns -1, 0, or 1 as `self` is less than, equal to, or greater than
  # `other_array`. For each index `i` in `self`, evaluates `result = self[i] <=>
  # other_array[i]`.
  #
  # Returns -1 if any result is -1:
  #
  #     [0, 1, 2] <=> [0, 1, 3] # => -1
  #
  # Returns 1 if any result is 1:
  #
  #     [0, 1, 2] <=> [0, 1, 1] # => 1
  #
  # When all results are zero:
  #
  # *   Returns -1 if `array` is smaller than `other_array`:
  #
  #         [0, 1, 2] <=> [0, 1, 2, 3] # => -1
  #
  # *   Returns 1 if `array` is larger than `other_array`:
  #
  #         [0, 1, 2] <=> [0, 1] # => 1
  #
  # *   Returns 0 if `array` and `other_array` are the same size:
  #
  #         [0, 1, 2] <=> [0, 1, 2] # => 0
  #
  def <=>: (untyped) -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array == other_array -> true or false
  # -->
  # Returns `true` if both `array.size == other_array.size` and for each index `i`
  # in `array`, `array[i] == other_array[i]`:
  #
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2.0]
  #     a1 == a0 # => true
  #     [] == [] # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method Array#eql?, which compares elements using
  # `Object#eql?`.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array[index] -> object or nil
  #   - array[start, length] -> object or nil
  #   - array[range] -> object or nil
  #   - array[aseq] -> object or nil
  #   - array.slice(index) -> object or nil
  #   - array.slice(start, length) -> object or nil
  #   - array.slice(range) -> object or nil
  #   - array.slice(aseq) -> object or nil
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When a single Integer argument `index` is given, returns the element at offset
  # `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts relative to the end of `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new Array
  # of size `length` containing successive elements beginning at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an Array of elements corresponding to the indexes produced by the sequence.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Array#slice is an alias for Array#[].
  #
  def []: %a{implicitly-returns-nil} (int index) -> Elem
        | (int start, int length) -> ::Array[Elem]?
        | (::Range[::Integer?]) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array[index] = object -> object
  #   - array[start, length] = object -> object
  #   - array[range] = object -> object
  # -->
  # Assigns elements in `self`; returns the given `object`.
  #
  # When Integer argument `index` is given, assigns `object` to an element in
  # `self`.
  #
  # If `index` is non-negative, assigns `object` the element at offset `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0] = 'foo' # => "foo"
  #     a # => ["foo", "bar", 2]
  #
  # If `index` is greater than `self.length`, extends the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[7] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
  #
  # If `index` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1] = 'two' # => "two"
  #     a # => [:foo, "bar", "two"]
  #
  # When Integer arguments `start` and `length` are given and `object` is not an
  # Array, removes `length - 1` elements beginning at offset `start`, and assigns
  # `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # If `start` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-2, 2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If `start` is non-negative and outside the array (` >= self.size`), extends
  # the array with `nil`, assigns `object` at offset `start`, and ignores
  # `length`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[6, 50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `length` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1, 0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `length` is too large for the existing array, does not extend the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1, 5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # When Range argument `range` is given and `object` is an Array, removes `length
  # - 1` elements beginning at offset `start`, and assigns `object` at offset
  # `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..1] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # if `range.begin` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-2..2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If the array length is less than `range.begin`, assigns `object` at offset
  # `range.begin`, and ignores `length`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[6..50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `range.end` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `range.end` is negative, assigns `object` at offset `start`, retains
  # `range.end.abs -1` elements past that, and removes those beyond:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..-1] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #     a = [:foo, 'bar', 2]
  #     a[1..-2] = 'foo' # => "foo"
  #     a # => [:foo, "foo", 2]
  #     a = [:foo, 'bar', 2]
  #     a[1..-3] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #     a = [:foo, 'bar', 2]
  #
  # If `range.end` is too large for the existing array, replaces array elements,
  # but does not extend the array with `nil` values:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  def []=: (int index, Elem obj) -> Elem
         | (int start, int length, Elem obj) -> Elem
         | (int start, int length, ::Array[Elem]) -> ::Array[Elem]
         | (int start, int length, nil) -> nil
         | (::Range[::Integer?], Elem obj) -> Elem
         | (::Range[::Integer?], ::Array[Elem]) -> ::Array[Elem]
         | (::Range[::Integer?], nil) -> nil

  # <!--
  #   rdoc-file=array.c
  #   - array.all? -> true or false
  #   - array.all? {|element| ... } -> true or false
  #   - array.all?(obj) -> true or false
  # -->
  # Returns `true` if all elements of `self` meet a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` contains only
  # truthy elements, `false` otherwise:
  #
  #     [0, 1, :foo].all? # => true
  #     [0, nil, 2].all? # => false
  #     [].all? # => true
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns only truthy values, `false`
  # otherwise:
  #
  #     [0, 1, 2].all? { |element| element < 3 } # => true
  #     [0, 1, 2].all? { |element| element < 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` every element, `false`
  # otherwise:
  #
  #     ['food', 'fool', 'foot'].all?(/foo/) # => true
  #     ['food', 'drink'].all?(/bar/) # => false
  #     [].all?(/foo/) # => true
  #     [0, 0, 0].all?(0) # => true
  #     [0, 1, 2].all?(1) # => false
  #
  # Related: Enumerable#all?
  #
  def all?: () -> bool
          | () { (Elem obj) -> boolish } -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.any? -> true or false
  #   - array.any? {|element| ... } -> true or false
  #   - array.any?(obj) -> true or false
  # -->
  # Returns `true` if any element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has any truthy
  # element, `false` otherwise:
  #
  #     [nil, 0, false].any? # => true
  #     [nil, false].any? # => false
  #     [].any? # => false
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns any truthy value, `false`
  # otherwise:
  #
  #     [0, 1, 2].any? {|element| element > 1 } # => true
  #     [0, 1, 2].any? {|element| element > 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj`.`===` any element, `false`
  # otherwise:
  #
  #     ['food', 'drink'].any?(/foo/) # => true
  #     ['food', 'drink'].any?(/bar/) # => false
  #     [].any?(/foo/) # => false
  #     [0, 1, 2].any?(1) # => true
  #     [0, 1, 2].any?(3) # => false
  #
  # Related: Enumerable#any?
  #
  alias any? all?

  def at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.clear -> self
  # -->
  # Removes all elements from `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.clear # => []
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.map! {|element| ... } -> self
  #   - array.map! -> new_enumerator
  # -->
  # Calls the block, if given, with each element; replaces the element with the
  # block's return value:
  #
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map!
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map!>
  #
  # Array#collect! is an alias for Array#map!.
  #
  def collect!: () { (Elem item) -> Elem } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.count -> an_integer
  #   - array.count(obj) -> an_integer
  #   - array.count {|element| ... } -> an_integer
  # -->
  # Returns a count of specified elements.
  #
  # With no argument and no block, returns the count of all elements:
  #
  #     [0, 1, 2].count # => 3
  #     [].count # => 0
  #
  # With argument `obj`, returns the count of elements `==` to `obj`:
  #
  #     [0, 1, 2, 0.0].count(0) # => 2
  #     [0, 1, 2].count(3) # => 0
  #
  # With no argument and a block given, calls the block with each element; returns
  # the count of elements for which the block returns a truthy value:
  #
  #     [0, 1, 2, 3].count {|element| element > 1} # => 2
  #
  # With argument `obj` and a block given, issues a warning, ignores the block,
  # and returns the count of elements `==` to `obj`.
  #
  def count: () -> ::Integer
           | (Elem obj) -> ::Integer
           | () { (Elem) -> boolish } -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_at(index) -> deleted_object or nil
  # -->
  # Deletes an element from `self`, per the given Integer `index`.
  #
  # When `index` is non-negative, deletes the element at offset `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # If index is too large, returns `nil`.
  #
  # When `index` is negative, counts backward from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(-2) # => "bar"
  #     a # => [:foo, 2]
  #
  # If `index` is too small (far from zero), returns nil.
  #
  def delete_at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_if {|element| ... } -> self
  #   - array.delete_if -> Enumerator
  # -->
  # Removes each element in +self+ for which the block returns a truthy value;
  #     returns +self+:
  #
  #       a = [:foo, 'bar', 2, 'bat']
  #       a.delete_if {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  #     Returns a new \Enumerator if no block given:
  #
  #       a = [:foo, 'bar', 2]
  #       a.delete_if # => #<Enumerator: [:foo, "bar", 2]:delete_if>
  #
  # 3
  #
  def delete_if: () { (Elem item) -> boolish } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.each {|element| ... } -> self
  #   - array.each -> Enumerator
  # -->
  # Iterates over array elements.
  #
  # When a block given, passes each successive array element to the block; returns
  # `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Allows the array to be modified during iteration:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #
  #     foo
  #     bar
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #
  #     e = a.each
  #     e # => #<Enumerator: [:foo, "bar", 2]:each>
  #     a1 = e.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Related: #each_index, #reverse_each.
  #
  def each: () { (Elem item) -> void } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.each_index {|index| ... } -> self
  #   - array.each_index -> Enumerator
  # -->
  # Iterates over array indexes.
  #
  # When a block given, passes each successive array index to the block; returns
  # `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index|  puts "#{index} #{a[index]}" }
  #
  # Output:
  #
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Allows the array to be modified during iteration:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index| puts index; a.clear if index > 0 }
  #
  # Output:
  #
  #     0
  #     1
  #
  # When no block given, returns a new Enumerator:
  #
  #     a = [:foo, 'bar', 2]
  #     e = a.each_index
  #     e # => #<Enumerator: [:foo, "bar", 2]:each_index>
  #     a1 = e.each {|index|  puts "#{index} #{a[index]}"}
  #
  # Output:
  #
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Related: #each, #reverse_each.
  #
  def each_index: () { (::Integer index) -> void } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.empty?  -> true or false
  # -->
  # Returns `true` if the count of elements in `self` is zero, `false` otherwise.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.index(object) -> integer or nil
  #   - array.index {|element| ... } -> integer or nil
  #   - array.index -> new_enumerator
  # -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  def find_index: (untyped obj) -> ::Integer?
                | () { (Elem item) -> boolish } -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array.first -> object or nil
  #   - array.first(n) -> new_array
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When no argument is given, returns the first element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.first # => :foo
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Integer argument `n` is given, returns the first `n`
  # elements in a new Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.first(2) # => [:foo, "bar"]
  #
  # If `n >= array.size`, returns all elements:
  #
  #     a = [:foo, 'bar', 2]
  #     a.first(50) # => [:foo, "bar", 2]
  #
  # If `n == 0` returns an new empty Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.first(0) # []
  #
  # Related: #last.
  #
  def first: () -> Elem?
           | (int n) -> ::Array[Elem]

  def flatten: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.include?(obj) -> true or false
  # -->
  # Returns `true` if for some index `i` in `self`, `obj == self[i]`; otherwise
  # `false`:
  #
  #     [0, 1, 2].include?(2) # => true
  #     [0, 1, 2].include?(3) # => false
  #
  def include?: (Elem object) -> bool

  # <!-- rdoc-file=array.c -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  alias index find_index

  # <!--
  #   rdoc-file=array.c
  #   - array.inspect -> new_string
  # -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.join ->new_string
  #   - array.join(separator = $,) -> new_string
  # -->
  # Returns the new String formed by joining the array elements after conversion.
  # For each element `element`:
  #
  # *   Uses `element.to_s` if `element` is not a `kind_of?(Array)`.
  # *   Uses recursive `element.join(separator)` if `element` is a
  #     `kind_of?(Array)`.
  #
  #
  # With no argument, joins using the output field separator, `$,`:
  #
  #     a = [:foo, 'bar', 2]
  #     $, # => nil
  #     a.join # => "foobar2"
  #
  # With string argument `separator`, joins using that separator:
  #
  #     a = [:foo, 'bar', 2]
  #     a.join("\n") # => "foo\nbar\n2"
  #
  # Joins recursively for nested Arrays:
  #
  #     a = [:foo, [:bar, [:baz, :bat]]]
  #     a.join # => "foobarbazbat"
  #
  def join: (?string separator) -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.last  -> object or nil
  #   - array.last(n) -> new_array
  # -->
  # Returns elements from `self`; `self` is not modified.
  #
  # When no argument is given, returns the last element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Integer argument `n` is given, returns the last `n` elements
  # in a new Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last(2) # => ["bar", 2]
  #
  # If `n >= array.size`, returns all elements:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last(50) # => [:foo, "bar", 2]
  #
  # If `n == 0`, returns an new empty Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last(0) # []
  #
  # Related: #first.
  #
  def last: () -> Elem?
          | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.length -> an_integer
  # -->
  # Returns the count of elements in `self`.
  #
  def length: () -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.max -> element
  #   - array.max {|a, b| ... } -> element
  #   - array.max(n) -> new_array
  #   - array.max(n) {|a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  #
  # *   The maximum-valued element from `self`.
  # *   A new Array of maximum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # maximum value per method `<=>`:
  #
  #     [0, 1, 2].max # => 2
  #
  # With an argument Integer `n` and no block, returns a new Array with at most
  # `n` elements, in descending order per method `<=>`:
  #
  #     [0, 1, 2, 3].max(3) # => [3, 2, 1]
  #     [0, 1, 2, 3].max(6) # => [3, 2, 1, 0]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the maximum value per the block:
  #
  #     ['0', '00', '000'].max {|a, b| a.size <=> b.size } # => "000"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in descending order per the block:
  #
  #     ['0', '00', '000'].max(2) {|a, b| a.size <=> b.size } # => ["000", "00"]
  #
  def max: () -> Elem?
         | () { (Elem a, Elem b) -> ::Integer? } -> Elem?
         | (int n) -> ::Array[Elem]
         | (int n) { (Elem a, Elem b) -> ::Integer? } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.min -> element
  #   - array.min { |a, b| ... } -> element
  #   - array.min(n) -> new_array
  #   - array.min(n) { |a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  #
  # *   The minimum-valued element from `self`.
  # *   A new Array of minimum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # minimum value per method `<=>`:
  #
  #     [0, 1, 2].min # => 0
  #
  # With Integer argument `n` and no block, returns a new Array with at most `n`
  # elements, in ascending order per method `<=>`:
  #
  #     [0, 1, 2, 3].min(3) # => [0, 1, 2]
  #     [0, 1, 2, 3].min(6) # => [0, 1, 2, 3]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the minimum value per the block:
  #
  #     ['0', '00', '000'].min { |a, b| a.size <=> b.size } # => "0"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in ascending order per the block:
  #
  #     ['0', '00', '000'].min(2) {|a, b| a.size <=> b.size } # => ["0", "00"]
  #
  alias min max

  # <!--
  #   rdoc-file=array.c
  #   - array.pop -> object or nil
  #   - array.pop(n) -> new_array
  # -->
  # Removes and returns trailing elements.
  #
  # When no argument is given and `self` is not empty, removes and returns the
  # last element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.pop # => 2
  #     a # => [:foo, "bar"]
  #
  # Returns `nil` if the array is empty.
  #
  # When a non-negative Integer argument `n` is given and is in range,
  #
  # removes and returns the last `n` elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.pop(2) # => ["bar", 2]
  #
  # If `n` is positive and out of range, removes and returns all elements:
  #
  #     a = [:foo, 'bar', 2]
  #     a.pop(50) # => [:foo, "bar", 2]
  #
  # Related: #push, #shift, #unshift.
  #
  def pop: () -> Elem?
         | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.push(*objects) -> self
  # -->
  # Appends trailing elements.
  #
  # Appends each argument in `objects` to `self`;  returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as one element, even if it is another Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a1 = a.push([:baz, :bat], [:bam, :bad])
  #     a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Array#append is an alias for Array#push.
  #
  # Related: #pop, #shift, #unshift.
  #
  def push: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.shift -> object or nil
  #   - array.shift(n) -> new_array
  # -->
  # Removes and returns leading elements.
  #
  # When no argument is given, removes and returns the first element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.shift # => :foo
  #     a # => ['bar', 2]
  #
  # Returns `nil` if `self` is empty.
  #
  # When positive Integer argument `n` is given, removes the first `n` elements;
  # returns those elements in a new Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.shift(2) # => [:foo, 'bar']
  #     a # => [2]
  #
  # If `n` is as large as or larger than `self.length`, removes all elements;
  # returns those elements in a new Array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.shift(3) # => [:foo, 'bar', 2]
  #
  # If `n` is zero, returns a new empty Array; `self` is unmodified.
  #
  # Related: #push, #pop, #unshift.
  #
  def shift: () -> Elem?
           | (int n) -> ::Array[Elem]

  # <!-- rdoc-file=array.c -->
  # Returns the count of elements in `self`.
  #
  alias size length

  # <!--
  #   rdoc-file=array.c
  #   - array.sort -> new_array
  #   - array.sort {|a, b| ... } -> new_array
  # -->
  # Returns a new Array whose elements are those from `self`, sorted.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort
  #     a1 # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  #
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| a <=> b }
  #     a1 # => ["a", "b", "c", "d", "e"]
  #     a2 = a.sort {|a, b| b <=> a }
  #     a2 # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| 0 }
  #     a1 # =>  ["c", "e", "b", "d", "a"]
  #
  # Related: Enumerable#sort_by.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem a, Elem b) -> ::Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.sort! -> self
  #   - array.sort! {|a, b| ... } -> self
  # -->
  # Returns `self` with its elements sorted in place.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort!
  #     a # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  #
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| a <=> b }
  #     a # => ["a", "b", "c", "d", "e"]
  #     a.sort! {|a, b| b <=> a }
  #     a # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| 0 }
  #     a # => ["d", "e", "c", "a", "b"]
  #
  def sort!: () -> self
           | () { (Elem a, Elem b) -> ::Integer } -> self

  # <!-- rdoc-file=array.c -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=array.c
  #   - array.unshift(*objects) -> self
  # -->
  # Prepends the given `objects` to `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Array#prepend is an alias for Array#unshift.
  #
  # Related: #push, #pop, #shift.
  #
  def unshift: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array | other_array -> new_array
  # -->
  # Returns the union of `array` and Array `other_array`; duplicates are removed;
  # order is preserved; items are compared using `eql?`:
  #
  #     [0, 1] | [2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 1] | [2, 2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 2] | [3, 2, 1, 0] # => [0, 1, 2, 3]
  #
  # Related: Array#union.
  #
  def |: [T] (::Array[T] other_ary) -> ::Array[Elem | T]

  # @ignore
  # To surpress an error in steep/lib/steep/interface/builder.rb:479
  def fetch: (int index) -> Elem

  def reject: () { (Elem item) -> boolish } -> ::Array[Elem]
  def reject!: () { (Elem item) -> boolish } -> self

  def uniq: () -> ::Array[Elem]
  def uniq!: () -> self
end

