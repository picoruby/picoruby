# Layer switching functionality for keyboard matrix
class Keyboard
  include USB::HID::Keycode
  include LayerKeycode

  # Transparent key constant
  KC_NO: Integer

  type key_event_t = {
    row: Integer,
    col: Integer,
    keycode: Integer,
    modifier: Integer,
    pressed: bool
  }

  type combo_entry_t = {
    keycodes: Array[Integer],
    action: Integer
  }

  type combo_buffer_entry_t = {
    key_pos: [Integer, Integer],
    pressed_at: Integer,
    keycode: Integer
  }

  type injected_event_t = {
    row: Integer,
    col: Integer,
    pressed: bool
  }

  @row_count: Integer
  @col_count: Integer
  @keymap_rows: Integer
  @keymap_cols: Integer
  @layers: Hash[Symbol, Array[Integer]]
  @layer_names: Array[Symbol]
  @default_layer: Symbol | nil
  @locked_layer: Integer | nil
  @layer_stack: Array[Integer]
  @momentary_keys: Hash[[Integer, Integer], Integer]
  @tap_hold_keys: Hash[[Integer, Integer], Hash[Symbol, untyped]]
  @tap_threshold_ms: Integer
  @repush_threshold_ms: Integer
  @keys_pressed: Hash[[Integer, Integer], bool]
  @active_keys: Hash[[Integer, Integer], Hash[Symbol, Integer]]
  @matrix: KeyboardMatrix
  @callback: (^(key_event_t) -> void) | nil

  # Combo key management
  @combos: Array[combo_entry_t]
  @combo_buffer: Array[combo_buffer_entry_t]
  @combo_term_ms: Integer
  @combo_reference_layer: Integer | nil

  # Split keyboard support
  @injected_events: Array[injected_event_t]

  # Initialize keyboard layer manager
  def self.new: (Array[Integer] row_pins, Array[Integer] col_pins, ?debounce_ms: Integer, ?keymap_rows: Integer?, ?keymap_cols: Integer?) -> Keyboard
  # Add a layer with name and keymap
  def add_layer: (Symbol name, Array[Integer] keymap) -> void
  # Set default layer
  def default_layer=: (Symbol name) -> void
  # Set tap threshold in milliseconds
  def tap_threshold_ms=: (Integer value) -> Integer
  # Set repush threshold in milliseconds
  def repush_threshold_ms=: (Integer value) -> Integer
  # Set combo detection window in milliseconds
  def combo_term_ms=: (Integer value) -> Integer
  # Set reference layer for combo detection
  def combo_reference_layer=: (Symbol? layer_name) -> (Integer | nil)
  # Add a combo definition
  def add_combo: (Array[Integer] keycodes, Integer action) -> void
  # Inject an external key event (for split keyboard support)
  def inject_event: (Integer row, Integer col, bool pressed) -> void
  # Start scanning loop
  def start: () { (key_event_t) -> void } -> void

  # Handle key event from KeyboardMatrix
  private def handle_event: (Hash[Symbol, untyped] event) -> void
  # Check if keycode is a modifier key
  private def is_modifier_key?: (Integer keycode) -> bool
  # Resolve keycode and modifier from layer stack
  private def resolve_key: (Integer row, Integer col) -> [Integer, Integer]
  # Resolve keycode from layer stack
  private def resolve_keycode: (Integer row, Integer col) -> Integer
  # Handle momentary layer key press/release
  private def handle_mo_key: (Integer row, Integer col, Integer layer_index, bool pressed) -> void
  # Handle toggle layer key press
  private def handle_tg_key: (Integer layer_index, bool pressed) -> void
  # Handle MT tap/hold key press/release
  private def handle_mt_key: (Integer row, Integer col, Integer modifier_index, Integer tap_keycode, bool pressed) -> void
  # Handle LT tap/hold key press/release
  private def handle_lt_key: (Integer row, Integer col, Integer layer_index, Integer tap_keycode, bool pressed) -> void
  # Update tap/hold key states
  private def update_tap_hold_keys: () -> void
  # Mark that another key was pressed
  private def mark_other_key_pressed: () -> void
  # Activate a momentary layer
  private def activate_layer: ([Integer, Integer] key_pos, Integer layer_index) -> void
  # Deactivate a momentary layer
  private def deactivate_layer: ([Integer, Integer] key_pos, Integer layer_index) -> void
  # Activate a modifier
  private def activate_modifier: ([Integer, Integer] key_pos, Integer modifier_index) -> void
  # Deactivate a modifier
  private def deactivate_modifier: ([Integer, Integer] key_pos) -> void

  # Combo detection methods
  # Resolve keycode for combo detection (with optional reference layer)
  private def resolve_keycode_for_combo: (Integer row, Integer col) -> Integer
  # Resolve keycode from a specific layer
  private def resolve_keycode_from_layer: (Integer row, Integer col, Integer layer_index) -> Integer
  # Check if keycode is part of any combo
  private def is_combo_keycode?: (Integer keycode) -> bool
  # Add key press to combo buffer
  private def add_to_combo_buffer: (Integer row, Integer col, Integer keycode) -> void
  # Check if any combo matches the current buffer
  private def check_combos: () -> (combo_entry_t | nil)
  # Execute combo action
  private def execute_combo: (combo_entry_t combo) -> void
  # Clean expired entries from combo buffer
  private def clean_expired_combo_buffer: () -> void
  # Flush a buffered key
  private def flush_buffered_key: (combo_buffer_entry_t entry) -> void
  # Check if key_pos is in combo buffer
  private def combo_buffer_has?: ([Integer, Integer] key_pos) -> bool
  # Handle release of a combo-buffered key
  private def handle_combo_key_release: ([Integer, Integer] key_pos) -> void
end
